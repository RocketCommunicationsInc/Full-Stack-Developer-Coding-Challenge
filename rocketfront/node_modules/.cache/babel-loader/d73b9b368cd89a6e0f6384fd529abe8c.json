{"ast":null,"code":"// pass\nvar P = function (prototype, ownProperty, undefined) {\n  return function P(_superclass\n  /* = Object */\n  , definition) {\n    // handle the case where no superclass is given\n    if (definition === undefined) {\n      definition = _superclass;\n      _superclass = Object;\n    } // C is the class to be returned.\n    //\n    // When called, creates and initializes an instance of C, unless\n    // `this` is already an instance of C, then just initializes `this`;\n    // either way, returns the instance of C that was initialized.\n    //\n    //  TODO: the Chrome inspector shows all created objects as `C`\n    //        rather than `Object`.  Setting the .name property seems to\n    //        have no effect.  Is there a way to override this behavior?\n\n\n    function C() {\n      var self = this instanceof C ? this : new Bare();\n      self.init.apply(self, arguments);\n      return self;\n    } // C.Bare is a class with a noop constructor.  Its prototype will be\n    // the same as C, so that instances of C.Bare are instances of C.\n    // `new MyClass.Bare` then creates new instances of C without\n    // calling .init().\n\n\n    function Bare() {}\n\n    C.Bare = Bare; // Extend the prototype chain: first use Bare to create an\n    // uninitialized instance of the superclass, then set up Bare\n    // to create instances of this class.\n\n    var _super = Bare[prototype] = _superclass[prototype];\n\n    var proto = Bare[prototype] = C[prototype] = C.p = new Bare(); // pre-declaring the iteration variable for the loop below to save\n    // a `var` keyword after minification\n\n    var key; // set the constructor property on the prototype, for convenience\n\n    proto.constructor = C;\n\n    C.extend = function (def) {\n      return P(C, def);\n    };\n\n    return (C.open = function (def) {\n      if (typeof def === 'function') {\n        // call the defining function with all the arguments you need\n        // extensions captures the return value.\n        def = def.call(C, proto, _super, C, _superclass);\n      } // ...and extend it\n\n\n      if (typeof def === 'object') {\n        for (key in def) {\n          if (ownProperty.call(def, key)) {\n            proto[key] = def[key];\n          }\n        }\n      } // if no init, assume we're inheriting from a non-Pjs class, so\n      // default to using the superclass constructor.\n\n\n      if (!('init' in proto)) proto.init = _superclass;\n      return C;\n    })(definition);\n  }; // as a minifier optimization, we've closured in a few helper functions\n  // and the string 'prototype' (C[p] is much shorter than C.prototype)\n}('prototype', {}.hasOwnProperty);\n\nexports.P = P;","map":{"version":3,"sources":["/home/mimirandi21/code/projects/Full-Stack-Developer-Coding-Challenge-1/rocketfront/node_modules/pjs/build/p.commonjs.js"],"names":["P","prototype","ownProperty","undefined","_superclass","definition","Object","C","self","Bare","init","apply","arguments","_super","proto","p","key","constructor","extend","def","open","call","hasOwnProperty","exports"],"mappings":"AAAA;AACA,IAAIA,CAAC,GAAI,UAASC,SAAT,EAAoBC,WAApB,EAAiCC,SAAjC,EAA4C;AACnD,SAAO,SAASH,CAAT,CAAWI;AAAY;AAAvB,IAAuCC,UAAvC,EAAmD;AACxD;AACA,QAAIA,UAAU,KAAKF,SAAnB,EAA8B;AAC5BE,MAAAA,UAAU,GAAGD,WAAb;AACAA,MAAAA,WAAW,GAAGE,MAAd;AACD,KALuD,CAOxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,aAASC,CAAT,GAAa;AACX,UAAIC,IAAI,GAAG,gBAAgBD,CAAhB,GAAoB,IAApB,GAA2B,IAAIE,IAAJ,EAAtC;AACAD,MAAAA,IAAI,CAACE,IAAL,CAAUC,KAAV,CAAgBH,IAAhB,EAAsBI,SAAtB;AACA,aAAOJ,IAAP;AACD,KApBuD,CAsBxD;AACA;AACA;AACA;;;AACA,aAASC,IAAT,GAAgB,CAAE;;AAClBF,IAAAA,CAAC,CAACE,IAAF,GAASA,IAAT,CA3BwD,CA6BxD;AACA;AACA;;AACA,QAAII,MAAM,GAAGJ,IAAI,CAACR,SAAD,CAAJ,GAAkBG,WAAW,CAACH,SAAD,CAA1C;;AACA,QAAIa,KAAK,GAAGL,IAAI,CAACR,SAAD,CAAJ,GAAkBM,CAAC,CAACN,SAAD,CAAD,GAAeM,CAAC,CAACQ,CAAF,GAAM,IAAIN,IAAJ,EAAnD,CAjCwD,CAmCxD;AACA;;AACA,QAAIO,GAAJ,CArCwD,CAuCxD;;AACAF,IAAAA,KAAK,CAACG,WAAN,GAAoBV,CAApB;;AAEAA,IAAAA,CAAC,CAACW,MAAF,GAAW,UAASC,GAAT,EAAc;AAAE,aAAOnB,CAAC,CAACO,CAAD,EAAIY,GAAJ,CAAR;AAAmB,KAA9C;;AAEA,WAAO,CAACZ,CAAC,CAACa,IAAF,GAAS,UAASD,GAAT,EAAc;AAC7B,UAAI,OAAOA,GAAP,KAAe,UAAnB,EAA+B;AAC7B;AACA;AACAA,QAAAA,GAAG,GAAGA,GAAG,CAACE,IAAJ,CAASd,CAAT,EAAYO,KAAZ,EAAmBD,MAAnB,EAA2BN,CAA3B,EAA8BH,WAA9B,CAAN;AACD,OAL4B,CAO7B;;;AACA,UAAI,OAAOe,GAAP,KAAe,QAAnB,EAA6B;AAC3B,aAAKH,GAAL,IAAYG,GAAZ,EAAiB;AACf,cAAIjB,WAAW,CAACmB,IAAZ,CAAiBF,GAAjB,EAAsBH,GAAtB,CAAJ,EAAgC;AAC9BF,YAAAA,KAAK,CAACE,GAAD,CAAL,GAAaG,GAAG,CAACH,GAAD,CAAhB;AACD;AACF;AACF,OAd4B,CAgB7B;AACA;;;AACA,UAAI,EAAE,UAAUF,KAAZ,CAAJ,EAAwBA,KAAK,CAACJ,IAAN,GAAaN,WAAb;AAExB,aAAOG,CAAP;AACD,KArBM,EAqBJF,UArBI,CAAP;AAsBD,GAlED,CADmD,CAqEnD;AACA;AACD,CAvEO,CAuEL,WAvEK,EAuES,EAAD,CAAKiB,cAvEb,CAAR;;AAwEAC,OAAO,CAACvB,CAAR,GAAYA,CAAZ","sourcesContent":["// pass\nvar P = (function(prototype, ownProperty, undefined) {\n  return function P(_superclass /* = Object */, definition) {\n    // handle the case where no superclass is given\n    if (definition === undefined) {\n      definition = _superclass;\n      _superclass = Object;\n    }\n\n    // C is the class to be returned.\n    //\n    // When called, creates and initializes an instance of C, unless\n    // `this` is already an instance of C, then just initializes `this`;\n    // either way, returns the instance of C that was initialized.\n    //\n    //  TODO: the Chrome inspector shows all created objects as `C`\n    //        rather than `Object`.  Setting the .name property seems to\n    //        have no effect.  Is there a way to override this behavior?\n    function C() {\n      var self = this instanceof C ? this : new Bare;\n      self.init.apply(self, arguments);\n      return self;\n    }\n\n    // C.Bare is a class with a noop constructor.  Its prototype will be\n    // the same as C, so that instances of C.Bare are instances of C.\n    // `new MyClass.Bare` then creates new instances of C without\n    // calling .init().\n    function Bare() {}\n    C.Bare = Bare;\n\n    // Extend the prototype chain: first use Bare to create an\n    // uninitialized instance of the superclass, then set up Bare\n    // to create instances of this class.\n    var _super = Bare[prototype] = _superclass[prototype];\n    var proto = Bare[prototype] = C[prototype] = C.p = new Bare;\n\n    // pre-declaring the iteration variable for the loop below to save\n    // a `var` keyword after minification\n    var key;\n\n    // set the constructor property on the prototype, for convenience\n    proto.constructor = C;\n\n    C.extend = function(def) { return P(C, def); }\n\n    return (C.open = function(def) {\n      if (typeof def === 'function') {\n        // call the defining function with all the arguments you need\n        // extensions captures the return value.\n        def = def.call(C, proto, _super, C, _superclass);\n      }\n\n      // ...and extend it\n      if (typeof def === 'object') {\n        for (key in def) {\n          if (ownProperty.call(def, key)) {\n            proto[key] = def[key];\n          }\n        }\n      }\n\n      // if no init, assume we're inheriting from a non-Pjs class, so\n      // default to using the superclass constructor.\n      if (!('init' in proto)) proto.init = _superclass;\n\n      return C;\n    })(definition);\n  }\n\n  // as a minifier optimization, we've closured in a few helper functions\n  // and the string 'prototype' (C[p] is much shorter than C.prototype)\n})('prototype', ({}).hasOwnProperty);\nexports.P = P;\n"]},"metadata":{},"sourceType":"script"}