{"ast":null,"code":"import { __assign, __values } from \"tslib\";\nimport { isInstanceOf, isString } from './is';\nimport { logger } from './logger';\nimport { getGlobalObject } from './misc';\nimport { fill } from './object';\nimport { getFunctionName } from './stacktrace';\nimport { supportsHistory, supportsNativeFetch } from './supports';\nvar global = getGlobalObject();\n/**\n * Instrument native APIs to call handlers that can be used to create breadcrumbs, APM spans etc.\n *  - Console API\n *  - Fetch API\n *  - XHR API\n *  - History API\n *  - DOM API (click/typing)\n *  - Error API\n *  - UnhandledRejection API\n */\n\nvar handlers = {};\nvar instrumented = {};\n/** Instruments given API */\n\nfunction instrument(type) {\n  if (instrumented[type]) {\n    return;\n  }\n\n  instrumented[type] = true;\n\n  switch (type) {\n    case 'console':\n      instrumentConsole();\n      break;\n\n    case 'dom':\n      instrumentDOM();\n      break;\n\n    case 'xhr':\n      instrumentXHR();\n      break;\n\n    case 'fetch':\n      instrumentFetch();\n      break;\n\n    case 'history':\n      instrumentHistory();\n      break;\n\n    case 'error':\n      instrumentError();\n      break;\n\n    case 'unhandledrejection':\n      instrumentUnhandledRejection();\n      break;\n\n    default:\n      logger.warn('unknown instrumentation type:', type);\n  }\n}\n/**\n * Add handler that will be called when given type of instrumentation triggers.\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\n\n\nexport function addInstrumentationHandler(handler) {\n  if (!handler || typeof handler.type !== 'string' || typeof handler.callback !== 'function') {\n    return;\n  }\n\n  handlers[handler.type] = handlers[handler.type] || [];\n  handlers[handler.type].push(handler.callback);\n  instrument(handler.type);\n}\n/** JSDoc */\n\nfunction triggerHandlers(type, data) {\n  var e_1, _a;\n\n  if (!type || !handlers[type]) {\n    return;\n  }\n\n  try {\n    for (var _b = __values(handlers[type] || []), _c = _b.next(); !_c.done; _c = _b.next()) {\n      var handler = _c.value;\n\n      try {\n        handler(data);\n      } catch (e) {\n        logger.error(\"Error while triggering instrumentation handler.\\nType: \" + type + \"\\nName: \" + getFunctionName(handler) + \"\\nError: \" + e);\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n}\n/** JSDoc */\n\n\nfunction instrumentConsole() {\n  if (!('console' in global)) {\n    return;\n  }\n\n  ['debug', 'info', 'warn', 'error', 'log', 'assert'].forEach(function (level) {\n    if (!(level in global.console)) {\n      return;\n    }\n\n    fill(global.console, level, function (originalConsoleLevel) {\n      return function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        triggerHandlers('console', {\n          args: args,\n          level: level\n        }); // this fails for some browsers. :(\n\n        if (originalConsoleLevel) {\n          Function.prototype.apply.call(originalConsoleLevel, global.console, args);\n        }\n      };\n    });\n  });\n}\n/** JSDoc */\n\n\nfunction instrumentFetch() {\n  if (!supportsNativeFetch()) {\n    return;\n  }\n\n  fill(global, 'fetch', function (originalFetch) {\n    return function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      var handlerData = {\n        args: args,\n        fetchData: {\n          method: getFetchMethod(args),\n          url: getFetchUrl(args)\n        },\n        startTimestamp: Date.now()\n      };\n      triggerHandlers('fetch', __assign({}, handlerData)); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\n      return originalFetch.apply(global, args).then(function (response) {\n        triggerHandlers('fetch', __assign(__assign({}, handlerData), {\n          endTimestamp: Date.now(),\n          response: response\n        }));\n        return response;\n      }, function (error) {\n        triggerHandlers('fetch', __assign(__assign({}, handlerData), {\n          endTimestamp: Date.now(),\n          error: error\n        })); // NOTE: If you are a Sentry user, and you are seeing this stack frame,\n        //       it means the sentry.javascript SDK caught an error invoking your application code.\n        //       This is expected behavior and NOT indicative of a bug with sentry.javascript.\n\n        throw error;\n      });\n    };\n  });\n}\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n\n/** Extract `method` from fetch call arguments */\n\n\nfunction getFetchMethod(fetchArgs) {\n  if (fetchArgs === void 0) {\n    fetchArgs = [];\n  }\n\n  if ('Request' in global && isInstanceOf(fetchArgs[0], Request) && fetchArgs[0].method) {\n    return String(fetchArgs[0].method).toUpperCase();\n  }\n\n  if (fetchArgs[1] && fetchArgs[1].method) {\n    return String(fetchArgs[1].method).toUpperCase();\n  }\n\n  return 'GET';\n}\n/** Extract `url` from fetch call arguments */\n\n\nfunction getFetchUrl(fetchArgs) {\n  if (fetchArgs === void 0) {\n    fetchArgs = [];\n  }\n\n  if (typeof fetchArgs[0] === 'string') {\n    return fetchArgs[0];\n  }\n\n  if ('Request' in global && isInstanceOf(fetchArgs[0], Request)) {\n    return fetchArgs[0].url;\n  }\n\n  return String(fetchArgs[0]);\n}\n/* eslint-enable @typescript-eslint/no-unsafe-member-access */\n\n/** JSDoc */\n\n\nfunction instrumentXHR() {\n  if (!('XMLHttpRequest' in global)) {\n    return;\n  } // Poor man's implementation of ES6 `Map`, tracking and keeping in sync key and value separately.\n\n\n  var requestKeys = [];\n  var requestValues = [];\n  var xhrproto = XMLHttpRequest.prototype;\n  fill(xhrproto, 'open', function (originalOpen) {\n    return function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      } // eslint-disable-next-line @typescript-eslint/no-this-alias\n\n\n      var xhr = this;\n      var url = args[1];\n      xhr.__sentry_xhr__ = {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        method: isString(args[0]) ? args[0].toUpperCase() : args[0],\n        url: args[1]\n      }; // if Sentry key appears in URL, don't capture it as a request\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\n      if (isString(url) && xhr.__sentry_xhr__.method === 'POST' && url.match(/sentry_key/)) {\n        xhr.__sentry_own_request__ = true;\n      }\n\n      var onreadystatechangeHandler = function () {\n        if (xhr.readyState === 4) {\n          try {\n            // touching statusCode in some platforms throws\n            // an exception\n            if (xhr.__sentry_xhr__) {\n              xhr.__sentry_xhr__.status_code = xhr.status;\n            }\n          } catch (e) {\n            /* do nothing */\n          }\n\n          try {\n            var requestPos = requestKeys.indexOf(xhr);\n\n            if (requestPos !== -1) {\n              // Make sure to pop both key and value to keep it in sync.\n              requestKeys.splice(requestPos);\n              var args_1 = requestValues.splice(requestPos)[0];\n\n              if (xhr.__sentry_xhr__ && args_1[0] !== undefined) {\n                xhr.__sentry_xhr__.body = args_1[0];\n              }\n            }\n          } catch (e) {\n            /* do nothing */\n          }\n\n          triggerHandlers('xhr', {\n            args: args,\n            endTimestamp: Date.now(),\n            startTimestamp: Date.now(),\n            xhr: xhr\n          });\n        }\n      };\n\n      if ('onreadystatechange' in xhr && typeof xhr.onreadystatechange === 'function') {\n        fill(xhr, 'onreadystatechange', function (original) {\n          return function () {\n            var readyStateArgs = [];\n\n            for (var _i = 0; _i < arguments.length; _i++) {\n              readyStateArgs[_i] = arguments[_i];\n            }\n\n            onreadystatechangeHandler();\n            return original.apply(xhr, readyStateArgs);\n          };\n        });\n      } else {\n        xhr.addEventListener('readystatechange', onreadystatechangeHandler);\n      }\n\n      return originalOpen.apply(xhr, args);\n    };\n  });\n  fill(xhrproto, 'send', function (originalSend) {\n    return function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      requestKeys.push(this);\n      requestValues.push(args);\n      triggerHandlers('xhr', {\n        args: args,\n        startTimestamp: Date.now(),\n        xhr: this\n      });\n      return originalSend.apply(this, args);\n    };\n  });\n}\n\nvar lastHref;\n/** JSDoc */\n\nfunction instrumentHistory() {\n  if (!supportsHistory()) {\n    return;\n  }\n\n  var oldOnPopState = global.onpopstate;\n\n  global.onpopstate = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var to = global.location.href; // keep track of the current URL state, as we always receive only the updated state\n\n    var from = lastHref;\n    lastHref = to;\n    triggerHandlers('history', {\n      from: from,\n      to: to\n    });\n\n    if (oldOnPopState) {\n      return oldOnPopState.apply(this, args);\n    }\n  };\n  /** @hidden */\n\n\n  function historyReplacementFunction(originalHistoryFunction) {\n    return function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      var url = args.length > 2 ? args[2] : undefined;\n\n      if (url) {\n        // coerce to string (this is what pushState does)\n        var from = lastHref;\n        var to = String(url); // keep track of the current URL state, as we always receive only the updated state\n\n        lastHref = to;\n        triggerHandlers('history', {\n          from: from,\n          to: to\n        });\n      }\n\n      return originalHistoryFunction.apply(this, args);\n    };\n  }\n\n  fill(global.history, 'pushState', historyReplacementFunction);\n  fill(global.history, 'replaceState', historyReplacementFunction);\n}\n\nvar debounceDuration = 1000;\nvar debounceTimerID;\nvar lastCapturedEvent;\n/**\n * Decide whether the current event should finish the debounce of previously captured one.\n * @param previous previously captured event\n * @param current event to be captured\n */\n\nfunction shouldShortcircuitPreviousDebounce(previous, current) {\n  // If there was no previous event, it should always be swapped for the new one.\n  if (!previous) {\n    return true;\n  } // If both events have different type, then user definitely performed two separate actions. e.g. click + keypress.\n\n\n  if (previous.type !== current.type) {\n    return true;\n  }\n\n  try {\n    // If both events have the same type, it's still possible that actions were performed on different targets.\n    // e.g. 2 clicks on different buttons.\n    if (previous.target !== current.target) {\n      return true;\n    }\n  } catch (e) {// just accessing `target` property can throw an exception in some rare circumstances\n    // see: https://github.com/getsentry/sentry-javascript/issues/838\n  } // If both events have the same type _and_ same `target` (an element which triggered an event, _not necessarily_\n  // to which an event listener was attached), we treat them as the same action, as we want to capture\n  // only one breadcrumb. e.g. multiple clicks on the same button, or typing inside a user input box.\n\n\n  return false;\n}\n/**\n * Decide whether an event should be captured.\n * @param event event to be captured\n */\n\n\nfunction shouldSkipDOMEvent(event) {\n  // We are only interested in filtering `keypress` events for now.\n  if (event.type !== 'keypress') {\n    return false;\n  }\n\n  try {\n    var target = event.target;\n\n    if (!target || !target.tagName) {\n      return true;\n    } // Only consider keypress events on actual input elements. This will disregard keypresses targeting body\n    // e.g.tabbing through elements, hotkeys, etc.\n\n\n    if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {\n      return false;\n    }\n  } catch (e) {// just accessing `target` property can throw an exception in some rare circumstances\n    // see: https://github.com/getsentry/sentry-javascript/issues/838\n  }\n\n  return true;\n}\n/**\n * Wraps addEventListener to capture UI breadcrumbs\n * @param handler function that will be triggered\n * @param globalListener indicates whether event was captured by the global event listener\n * @returns wrapped breadcrumb events handler\n * @hidden\n */\n\n\nfunction makeDOMEventHandler(handler, globalListener) {\n  if (globalListener === void 0) {\n    globalListener = false;\n  }\n\n  return function (event) {\n    // It's possible this handler might trigger multiple times for the same\n    // event (e.g. event propagation through node ancestors).\n    // Ignore if we've already captured that event.\n    if (!event || lastCapturedEvent === event) {\n      return;\n    } // We always want to skip _some_ events.\n\n\n    if (shouldSkipDOMEvent(event)) {\n      return;\n    }\n\n    var name = event.type === 'keypress' ? 'input' : event.type; // If there is no debounce timer, it means that we can safely capture the new event and store it for future comparisons.\n\n    if (debounceTimerID === undefined) {\n      handler({\n        event: event,\n        name: name,\n        global: globalListener\n      });\n      lastCapturedEvent = event;\n    } // If there is a debounce awaiting, see if the new event is different enough to treat it as a unique one.\n    // If that's the case, emit the previous event and store locally the newly-captured DOM event.\n    else if (shouldShortcircuitPreviousDebounce(lastCapturedEvent, event)) {\n        handler({\n          event: event,\n          name: name,\n          global: globalListener\n        });\n        lastCapturedEvent = event;\n      } // Start a new debounce timer that will prevent us from capturing multiple events that should be grouped together.\n\n\n    clearTimeout(debounceTimerID);\n    debounceTimerID = global.setTimeout(function () {\n      debounceTimerID = undefined;\n    }, debounceDuration);\n  };\n}\n/** JSDoc */\n\n\nfunction instrumentDOM() {\n  if (!('document' in global)) {\n    return;\n  } // Make it so that any click or keypress that is unhandled / bubbled up all the way to the document triggers our dom\n  // handlers. (Normally we have only one, which captures a breadcrumb for each click or keypress.) Do this before\n  // we instrument `addEventListener` so that we don't end up attaching this handler twice.\n\n\n  var triggerDOMHandler = triggerHandlers.bind(null, 'dom');\n  var globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);\n  global.document.addEventListener('click', globalDOMEventHandler, false);\n  global.document.addEventListener('keypress', globalDOMEventHandler, false); // After hooking into click and keypress events bubbled up to `document`, we also hook into user-handled\n  // clicks & keypresses, by adding an event listener of our own to any element to which they add a listener. That\n  // way, whenever one of their handlers is triggered, ours will be, too. (This is needed because their handler\n  // could potentially prevent the event from bubbling up to our global listeners. This way, our handler are still\n  // guaranteed to fire at least once.)\n\n  ['EventTarget', 'Node'].forEach(function (target) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    var proto = global[target] && global[target].prototype; // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, no-prototype-builtins\n\n    if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {\n      return;\n    }\n\n    fill(proto, 'addEventListener', function (originalAddEventListener) {\n      return function (type, listener, options) {\n        if (type === 'click' || type == 'keypress') {\n          try {\n            var el = this;\n            var handlers_1 = el.__sentry_instrumentation_handlers__ = el.__sentry_instrumentation_handlers__ || {};\n            var handlerForType = handlers_1[type] = handlers_1[type] || {\n              refCount: 0\n            };\n\n            if (!handlerForType.handler) {\n              var handler = makeDOMEventHandler(triggerDOMHandler);\n              handlerForType.handler = handler;\n              originalAddEventListener.call(this, type, handler, options);\n            }\n\n            handlerForType.refCount += 1;\n          } catch (e) {// Accessing dom properties is always fragile.\n            // Also allows us to skip `addEventListenrs` calls with no proper `this` context.\n          }\n        }\n\n        return originalAddEventListener.call(this, type, listener, options);\n      };\n    });\n    fill(proto, 'removeEventListener', function (originalRemoveEventListener) {\n      return function (type, listener, options) {\n        if (type === 'click' || type == 'keypress') {\n          try {\n            var el = this;\n            var handlers_2 = el.__sentry_instrumentation_handlers__ || {};\n            var handlerForType = handlers_2[type];\n\n            if (handlerForType) {\n              handlerForType.refCount -= 1; // If there are no longer any custom handlers of the current type on this element, we can remove ours, too.\n\n              if (handlerForType.refCount <= 0) {\n                originalRemoveEventListener.call(this, type, handlerForType.handler, options);\n                handlerForType.handler = undefined;\n                delete handlers_2[type]; // eslint-disable-line @typescript-eslint/no-dynamic-delete\n              } // If there are no longer any custom handlers of any type on this element, cleanup everything.\n\n\n              if (Object.keys(handlers_2).length === 0) {\n                delete el.__sentry_instrumentation_handlers__;\n              }\n            }\n          } catch (e) {// Accessing dom properties is always fragile.\n            // Also allows us to skip `addEventListenrs` calls with no proper `this` context.\n          }\n        }\n\n        return originalRemoveEventListener.call(this, type, listener, options);\n      };\n    });\n  });\n}\n\nvar _oldOnErrorHandler = null;\n/** JSDoc */\n\nfunction instrumentError() {\n  _oldOnErrorHandler = global.onerror;\n\n  global.onerror = function (msg, url, line, column, error) {\n    triggerHandlers('error', {\n      column: column,\n      error: error,\n      line: line,\n      msg: msg,\n      url: url\n    });\n\n    if (_oldOnErrorHandler) {\n      // eslint-disable-next-line prefer-rest-params\n      return _oldOnErrorHandler.apply(this, arguments);\n    }\n\n    return false;\n  };\n}\n\nvar _oldOnUnhandledRejectionHandler = null;\n/** JSDoc */\n\nfunction instrumentUnhandledRejection() {\n  _oldOnUnhandledRejectionHandler = global.onunhandledrejection;\n\n  global.onunhandledrejection = function (e) {\n    triggerHandlers('unhandledrejection', e);\n\n    if (_oldOnUnhandledRejectionHandler) {\n      // eslint-disable-next-line prefer-rest-params\n      return _oldOnUnhandledRejectionHandler.apply(this, arguments);\n    }\n\n    return true;\n  };\n}","map":{"version":3,"sources":["../src/instrument.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/ban-types */\nimport { WrappedFunction } from '@sentry/types';\n\nimport { isInstanceOf, isString } from './is';\nimport { logger } from './logger';\nimport { getGlobalObject } from './misc';\nimport { fill } from './object';\nimport { getFunctionName } from './stacktrace';\nimport { supportsHistory, supportsNativeFetch } from './supports';\n\nconst global = getGlobalObject<Window>();\n\n/** Object describing handler that will be triggered for a given `type` of instrumentation */\ninterface InstrumentHandler {\n  type: InstrumentHandlerType;\n  callback: InstrumentHandlerCallback;\n}\ntype InstrumentHandlerType =\n  | 'console'\n  | 'dom'\n  | 'fetch'\n  | 'history'\n  | 'sentry'\n  | 'xhr'\n  | 'error'\n  | 'unhandledrejection';\ntype InstrumentHandlerCallback = (data: any) => void;\n\n/**\n * Instrument native APIs to call handlers that can be used to create breadcrumbs, APM spans etc.\n *  - Console API\n *  - Fetch API\n *  - XHR API\n *  - History API\n *  - DOM API (click/typing)\n *  - Error API\n *  - UnhandledRejection API\n */\n\nconst handlers: { [key in InstrumentHandlerType]?: InstrumentHandlerCallback[] } = {};\nconst instrumented: { [key in InstrumentHandlerType]?: boolean } = {};\n\n/** Instruments given API */\nfunction instrument(type: InstrumentHandlerType): void {\n  if (instrumented[type]) {\n    return;\n  }\n\n  instrumented[type] = true;\n\n  switch (type) {\n    case 'console':\n      instrumentConsole();\n      break;\n    case 'dom':\n      instrumentDOM();\n      break;\n    case 'xhr':\n      instrumentXHR();\n      break;\n    case 'fetch':\n      instrumentFetch();\n      break;\n    case 'history':\n      instrumentHistory();\n      break;\n    case 'error':\n      instrumentError();\n      break;\n    case 'unhandledrejection':\n      instrumentUnhandledRejection();\n      break;\n    default:\n      logger.warn('unknown instrumentation type:', type);\n  }\n}\n\n/**\n * Add handler that will be called when given type of instrumentation triggers.\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nexport function addInstrumentationHandler(handler: InstrumentHandler): void {\n  if (!handler || typeof handler.type !== 'string' || typeof handler.callback !== 'function') {\n    return;\n  }\n  handlers[handler.type] = handlers[handler.type] || [];\n  (handlers[handler.type] as InstrumentHandlerCallback[]).push(handler.callback);\n  instrument(handler.type);\n}\n\n/** JSDoc */\nfunction triggerHandlers(type: InstrumentHandlerType, data: any): void {\n  if (!type || !handlers[type]) {\n    return;\n  }\n\n  for (const handler of handlers[type] || []) {\n    try {\n      handler(data);\n    } catch (e) {\n      logger.error(\n        `Error while triggering instrumentation handler.\\nType: ${type}\\nName: ${getFunctionName(\n          handler,\n        )}\\nError: ${e}`,\n      );\n    }\n  }\n}\n\n/** JSDoc */\nfunction instrumentConsole(): void {\n  if (!('console' in global)) {\n    return;\n  }\n\n  ['debug', 'info', 'warn', 'error', 'log', 'assert'].forEach(function(level: string): void {\n    if (!(level in global.console)) {\n      return;\n    }\n\n    fill(global.console, level, function(originalConsoleLevel: () => any): Function {\n      return function(...args: any[]): void {\n        triggerHandlers('console', { args, level });\n\n        // this fails for some browsers. :(\n        if (originalConsoleLevel) {\n          Function.prototype.apply.call(originalConsoleLevel, global.console, args);\n        }\n      };\n    });\n  });\n}\n\n/** JSDoc */\nfunction instrumentFetch(): void {\n  if (!supportsNativeFetch()) {\n    return;\n  }\n\n  fill(global, 'fetch', function(originalFetch: () => void): () => void {\n    return function(...args: any[]): void {\n      const handlerData = {\n        args,\n        fetchData: {\n          method: getFetchMethod(args),\n          url: getFetchUrl(args),\n        },\n        startTimestamp: Date.now(),\n      };\n\n      triggerHandlers('fetch', {\n        ...handlerData,\n      });\n\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      return originalFetch.apply(global, args).then(\n        (response: Response) => {\n          triggerHandlers('fetch', {\n            ...handlerData,\n            endTimestamp: Date.now(),\n            response,\n          });\n          return response;\n        },\n        (error: Error) => {\n          triggerHandlers('fetch', {\n            ...handlerData,\n            endTimestamp: Date.now(),\n            error,\n          });\n          // NOTE: If you are a Sentry user, and you are seeing this stack frame,\n          //       it means the sentry.javascript SDK caught an error invoking your application code.\n          //       This is expected behavior and NOT indicative of a bug with sentry.javascript.\n          throw error;\n        },\n      );\n    };\n  });\n}\n\ntype XHRSendInput = null | Blob | BufferSource | FormData | URLSearchParams | string;\n\n/** JSDoc */\ninterface SentryWrappedXMLHttpRequest extends XMLHttpRequest {\n  [key: string]: any;\n  __sentry_xhr__?: {\n    method?: string;\n    url?: string;\n    status_code?: number;\n    body?: XHRSendInput;\n  };\n}\n\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/** Extract `method` from fetch call arguments */\nfunction getFetchMethod(fetchArgs: any[] = []): string {\n  if ('Request' in global && isInstanceOf(fetchArgs[0], Request) && fetchArgs[0].method) {\n    return String(fetchArgs[0].method).toUpperCase();\n  }\n  if (fetchArgs[1] && fetchArgs[1].method) {\n    return String(fetchArgs[1].method).toUpperCase();\n  }\n  return 'GET';\n}\n\n/** Extract `url` from fetch call arguments */\nfunction getFetchUrl(fetchArgs: any[] = []): string {\n  if (typeof fetchArgs[0] === 'string') {\n    return fetchArgs[0];\n  }\n  if ('Request' in global && isInstanceOf(fetchArgs[0], Request)) {\n    return fetchArgs[0].url;\n  }\n  return String(fetchArgs[0]);\n}\n/* eslint-enable @typescript-eslint/no-unsafe-member-access */\n\n/** JSDoc */\nfunction instrumentXHR(): void {\n  if (!('XMLHttpRequest' in global)) {\n    return;\n  }\n\n  // Poor man's implementation of ES6 `Map`, tracking and keeping in sync key and value separately.\n  const requestKeys: XMLHttpRequest[] = [];\n  const requestValues: Array<any>[] = [];\n  const xhrproto = XMLHttpRequest.prototype;\n\n  fill(xhrproto, 'open', function(originalOpen: () => void): () => void {\n    return function(this: SentryWrappedXMLHttpRequest, ...args: any[]): void {\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      const xhr = this;\n      const url = args[1];\n      xhr.__sentry_xhr__ = {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        method: isString(args[0]) ? args[0].toUpperCase() : args[0],\n        url: args[1],\n      };\n\n      // if Sentry key appears in URL, don't capture it as a request\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      if (isString(url) && xhr.__sentry_xhr__.method === 'POST' && url.match(/sentry_key/)) {\n        xhr.__sentry_own_request__ = true;\n      }\n\n      const onreadystatechangeHandler = function(): void {\n        if (xhr.readyState === 4) {\n          try {\n            // touching statusCode in some platforms throws\n            // an exception\n            if (xhr.__sentry_xhr__) {\n              xhr.__sentry_xhr__.status_code = xhr.status;\n            }\n          } catch (e) {\n            /* do nothing */\n          }\n\n          try {\n            const requestPos = requestKeys.indexOf(xhr);\n            if (requestPos !== -1) {\n              // Make sure to pop both key and value to keep it in sync.\n              requestKeys.splice(requestPos);\n              const args = requestValues.splice(requestPos)[0];\n              if (xhr.__sentry_xhr__ && args[0] !== undefined) {\n                xhr.__sentry_xhr__.body = args[0] as XHRSendInput;\n              }\n            }\n          } catch (e) {\n            /* do nothing */\n          }\n\n          triggerHandlers('xhr', {\n            args,\n            endTimestamp: Date.now(),\n            startTimestamp: Date.now(),\n            xhr,\n          });\n        }\n      };\n\n      if ('onreadystatechange' in xhr && typeof xhr.onreadystatechange === 'function') {\n        fill(xhr, 'onreadystatechange', function(original: WrappedFunction): Function {\n          return function(...readyStateArgs: any[]): void {\n            onreadystatechangeHandler();\n            return original.apply(xhr, readyStateArgs);\n          };\n        });\n      } else {\n        xhr.addEventListener('readystatechange', onreadystatechangeHandler);\n      }\n\n      return originalOpen.apply(xhr, args);\n    };\n  });\n\n  fill(xhrproto, 'send', function(originalSend: () => void): () => void {\n    return function(this: SentryWrappedXMLHttpRequest, ...args: any[]): void {\n      requestKeys.push(this);\n      requestValues.push(args);\n\n      triggerHandlers('xhr', {\n        args,\n        startTimestamp: Date.now(),\n        xhr: this,\n      });\n\n      return originalSend.apply(this, args);\n    };\n  });\n}\n\nlet lastHref: string;\n\n/** JSDoc */\nfunction instrumentHistory(): void {\n  if (!supportsHistory()) {\n    return;\n  }\n\n  const oldOnPopState = global.onpopstate;\n  global.onpopstate = function(this: WindowEventHandlers, ...args: any[]): any {\n    const to = global.location.href;\n    // keep track of the current URL state, as we always receive only the updated state\n    const from = lastHref;\n    lastHref = to;\n    triggerHandlers('history', {\n      from,\n      to,\n    });\n    if (oldOnPopState) {\n      return oldOnPopState.apply(this, args);\n    }\n  };\n\n  /** @hidden */\n  function historyReplacementFunction(originalHistoryFunction: () => void): () => void {\n    return function(this: History, ...args: any[]): void {\n      const url = args.length > 2 ? args[2] : undefined;\n      if (url) {\n        // coerce to string (this is what pushState does)\n        const from = lastHref;\n        const to = String(url);\n        // keep track of the current URL state, as we always receive only the updated state\n        lastHref = to;\n        triggerHandlers('history', {\n          from,\n          to,\n        });\n      }\n      return originalHistoryFunction.apply(this, args);\n    };\n  }\n\n  fill(global.history, 'pushState', historyReplacementFunction);\n  fill(global.history, 'replaceState', historyReplacementFunction);\n}\n\nconst debounceDuration = 1000;\nlet debounceTimerID: number | undefined;\nlet lastCapturedEvent: Event | undefined;\n\n/**\n * Decide whether the current event should finish the debounce of previously captured one.\n * @param previous previously captured event\n * @param current event to be captured\n */\nfunction shouldShortcircuitPreviousDebounce(previous: Event | undefined, current: Event): boolean {\n  // If there was no previous event, it should always be swapped for the new one.\n  if (!previous) {\n    return true;\n  }\n\n  // If both events have different type, then user definitely performed two separate actions. e.g. click + keypress.\n  if (previous.type !== current.type) {\n    return true;\n  }\n\n  try {\n    // If both events have the same type, it's still possible that actions were performed on different targets.\n    // e.g. 2 clicks on different buttons.\n    if (previous.target !== current.target) {\n      return true;\n    }\n  } catch (e) {\n    // just accessing `target` property can throw an exception in some rare circumstances\n    // see: https://github.com/getsentry/sentry-javascript/issues/838\n  }\n\n  // If both events have the same type _and_ same `target` (an element which triggered an event, _not necessarily_\n  // to which an event listener was attached), we treat them as the same action, as we want to capture\n  // only one breadcrumb. e.g. multiple clicks on the same button, or typing inside a user input box.\n  return false;\n}\n\n/**\n * Decide whether an event should be captured.\n * @param event event to be captured\n */\nfunction shouldSkipDOMEvent(event: Event): boolean {\n  // We are only interested in filtering `keypress` events for now.\n  if (event.type !== 'keypress') {\n    return false;\n  }\n\n  try {\n    const target = event.target as HTMLElement;\n\n    if (!target || !target.tagName) {\n      return true;\n    }\n\n    // Only consider keypress events on actual input elements. This will disregard keypresses targeting body\n    // e.g.tabbing through elements, hotkeys, etc.\n    if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {\n      return false;\n    }\n  } catch (e) {\n    // just accessing `target` property can throw an exception in some rare circumstances\n    // see: https://github.com/getsentry/sentry-javascript/issues/838\n  }\n\n  return true;\n}\n\n/**\n * Wraps addEventListener to capture UI breadcrumbs\n * @param handler function that will be triggered\n * @param globalListener indicates whether event was captured by the global event listener\n * @returns wrapped breadcrumb events handler\n * @hidden\n */\nfunction makeDOMEventHandler(handler: Function, globalListener: boolean = false): (event: Event) => void {\n  return (event: Event): void => {\n    // It's possible this handler might trigger multiple times for the same\n    // event (e.g. event propagation through node ancestors).\n    // Ignore if we've already captured that event.\n    if (!event || lastCapturedEvent === event) {\n      return;\n    }\n\n    // We always want to skip _some_ events.\n    if (shouldSkipDOMEvent(event)) {\n      return;\n    }\n\n    const name = event.type === 'keypress' ? 'input' : event.type;\n\n    // If there is no debounce timer, it means that we can safely capture the new event and store it for future comparisons.\n    if (debounceTimerID === undefined) {\n      handler({\n        event: event,\n        name,\n        global: globalListener,\n      });\n      lastCapturedEvent = event;\n    }\n    // If there is a debounce awaiting, see if the new event is different enough to treat it as a unique one.\n    // If that's the case, emit the previous event and store locally the newly-captured DOM event.\n    else if (shouldShortcircuitPreviousDebounce(lastCapturedEvent, event)) {\n      handler({\n        event: event,\n        name,\n        global: globalListener,\n      });\n      lastCapturedEvent = event;\n    }\n\n    // Start a new debounce timer that will prevent us from capturing multiple events that should be grouped together.\n    clearTimeout(debounceTimerID);\n    debounceTimerID = global.setTimeout(() => {\n      debounceTimerID = undefined;\n    }, debounceDuration);\n  };\n}\n\ntype AddEventListener = (\n  type: string,\n  listener: EventListenerOrEventListenerObject,\n  options?: boolean | AddEventListenerOptions,\n) => void;\ntype RemoveEventListener = (\n  type: string,\n  listener: EventListenerOrEventListenerObject,\n  options?: boolean | EventListenerOptions,\n) => void;\n\ntype InstrumentedElement = Element & {\n  __sentry_instrumentation_handlers__?: {\n    [key in 'click' | 'keypress']?: {\n      handler?: Function;\n      /** The number of custom listeners attached to this element */\n      refCount: number;\n    };\n  };\n};\n\n/** JSDoc */\nfunction instrumentDOM(): void {\n  if (!('document' in global)) {\n    return;\n  }\n\n  // Make it so that any click or keypress that is unhandled / bubbled up all the way to the document triggers our dom\n  // handlers. (Normally we have only one, which captures a breadcrumb for each click or keypress.) Do this before\n  // we instrument `addEventListener` so that we don't end up attaching this handler twice.\n  const triggerDOMHandler = triggerHandlers.bind(null, 'dom');\n  const globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);\n  global.document.addEventListener('click', globalDOMEventHandler, false);\n  global.document.addEventListener('keypress', globalDOMEventHandler, false);\n\n  // After hooking into click and keypress events bubbled up to `document`, we also hook into user-handled\n  // clicks & keypresses, by adding an event listener of our own to any element to which they add a listener. That\n  // way, whenever one of their handlers is triggered, ours will be, too. (This is needed because their handler\n  // could potentially prevent the event from bubbling up to our global listeners. This way, our handler are still\n  // guaranteed to fire at least once.)\n  ['EventTarget', 'Node'].forEach((target: string) => {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    const proto = (global as any)[target] && (global as any)[target].prototype;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, no-prototype-builtins\n    if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {\n      return;\n    }\n\n    fill(proto, 'addEventListener', function(originalAddEventListener: AddEventListener): AddEventListener {\n      return function(\n        this: Element,\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n        options?: boolean | AddEventListenerOptions,\n      ): AddEventListener {\n        if (type === 'click' || type == 'keypress') {\n          try {\n            const el = this as InstrumentedElement;\n            const handlers = (el.__sentry_instrumentation_handlers__ = el.__sentry_instrumentation_handlers__ || {});\n            const handlerForType = (handlers[type] = handlers[type] || { refCount: 0 });\n\n            if (!handlerForType.handler) {\n              const handler = makeDOMEventHandler(triggerDOMHandler);\n              handlerForType.handler = handler;\n              originalAddEventListener.call(this, type, handler, options);\n            }\n\n            handlerForType.refCount += 1;\n          } catch (e) {\n            // Accessing dom properties is always fragile.\n            // Also allows us to skip `addEventListenrs` calls with no proper `this` context.\n          }\n        }\n\n        return originalAddEventListener.call(this, type, listener, options);\n      };\n    });\n\n    fill(proto, 'removeEventListener', function(originalRemoveEventListener: RemoveEventListener): RemoveEventListener {\n      return function(\n        this: Element,\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n        options?: boolean | EventListenerOptions,\n      ): () => void {\n        if (type === 'click' || type == 'keypress') {\n          try {\n            const el = this as InstrumentedElement;\n            const handlers = el.__sentry_instrumentation_handlers__ || {};\n            const handlerForType = handlers[type];\n\n            if (handlerForType) {\n              handlerForType.refCount -= 1;\n              // If there are no longer any custom handlers of the current type on this element, we can remove ours, too.\n              if (handlerForType.refCount <= 0) {\n                originalRemoveEventListener.call(this, type, handlerForType.handler, options);\n                handlerForType.handler = undefined;\n                delete handlers[type]; // eslint-disable-line @typescript-eslint/no-dynamic-delete\n              }\n\n              // If there are no longer any custom handlers of any type on this element, cleanup everything.\n              if (Object.keys(handlers).length === 0) {\n                delete el.__sentry_instrumentation_handlers__;\n              }\n            }\n          } catch (e) {\n            // Accessing dom properties is always fragile.\n            // Also allows us to skip `addEventListenrs` calls with no proper `this` context.\n          }\n        }\n\n        return originalRemoveEventListener.call(this, type, listener, options);\n      };\n    });\n  });\n}\n\nlet _oldOnErrorHandler: OnErrorEventHandler = null;\n/** JSDoc */\nfunction instrumentError(): void {\n  _oldOnErrorHandler = global.onerror;\n\n  global.onerror = function(msg: any, url: any, line: any, column: any, error: any): boolean {\n    triggerHandlers('error', {\n      column,\n      error,\n      line,\n      msg,\n      url,\n    });\n\n    if (_oldOnErrorHandler) {\n      // eslint-disable-next-line prefer-rest-params\n      return _oldOnErrorHandler.apply(this, arguments);\n    }\n\n    return false;\n  };\n}\n\nlet _oldOnUnhandledRejectionHandler: ((e: any) => void) | null = null;\n/** JSDoc */\nfunction instrumentUnhandledRejection(): void {\n  _oldOnUnhandledRejectionHandler = global.onunhandledrejection;\n\n  global.onunhandledrejection = function(e: any): boolean {\n    triggerHandlers('unhandledrejection', e);\n\n    if (_oldOnUnhandledRejectionHandler) {\n      // eslint-disable-next-line prefer-rest-params\n      return _oldOnUnhandledRejectionHandler.apply(this, arguments);\n    }\n\n    return true;\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}