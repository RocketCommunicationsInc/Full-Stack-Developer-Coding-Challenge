{"ast":null,"code":"import tzTokenizeDate from '../tzTokenizeDate/index.js';\nvar MILLISECONDS_IN_HOUR = 3600000;\nvar MILLISECONDS_IN_MINUTE = 60000;\nvar patterns = {\n  timezone: /([Z+-].*)$/,\n  timezoneZ: /^(Z)$/,\n  timezoneHH: /^([+-])(\\d{2})$/,\n  timezoneHHMM: /^([+-])(\\d{2}):?(\\d{2})$/,\n  timezoneIANA: /(UTC|(?:[a-zA-Z]+\\/[a-zA-Z_-]+(?:\\/[a-zA-Z_]+)?))$/\n}; // Parse various time zone offset formats to an offset in milliseconds\n\nexport default function tzParseTimezone(timezoneString, date, isUtcDate) {\n  var token;\n  var absoluteOffset; // Z\n\n  token = patterns.timezoneZ.exec(timezoneString);\n\n  if (token) {\n    return 0;\n  }\n\n  var hours; // ±hh\n\n  token = patterns.timezoneHH.exec(timezoneString);\n\n  if (token) {\n    hours = parseInt(token[2], 10);\n\n    if (!validateTimezone(hours)) {\n      return NaN;\n    }\n\n    absoluteOffset = hours * MILLISECONDS_IN_HOUR;\n    return token[1] === '+' ? -absoluteOffset : absoluteOffset;\n  } // ±hh:mm or ±hhmm\n\n\n  token = patterns.timezoneHHMM.exec(timezoneString);\n\n  if (token) {\n    hours = parseInt(token[2], 10);\n    var minutes = parseInt(token[3], 10);\n\n    if (!validateTimezone(hours, minutes)) {\n      return NaN;\n    }\n\n    absoluteOffset = hours * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE;\n    return token[1] === '+' ? -absoluteOffset : absoluteOffset;\n  } // IANA time zone\n\n\n  token = patterns.timezoneIANA.exec(timezoneString);\n\n  if (token) {\n    date = new Date(date || Date.now());\n    var utcDate = isUtcDate ? date : toUtcDate(date);\n    var offset = calcOffset(utcDate, timezoneString);\n    var fixedOffset = isUtcDate ? offset : fixOffset(date, offset, timezoneString);\n    return -fixedOffset;\n  }\n\n  return 0;\n}\n\nfunction toUtcDate(date) {\n  return new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));\n}\n\nfunction calcOffset(date, timezoneString) {\n  var [year, month, day, hour, minute, second] = tzTokenizeDate(date, timezoneString);\n  var asUTC = Date.UTC(year, month - 1, day, hour % 24, minute, second);\n  var asTS = date.getTime();\n  var over = asTS % 1000;\n  asTS -= over >= 0 ? over : 1000 + over;\n  return asUTC - asTS;\n}\n\nfunction fixOffset(date, offset, timezoneString) {\n  var localTS = date.getTime(); // Our UTC time is just a guess because our offset is just a guess\n\n  var utcGuess = localTS - offset; // Test whether the zone matches the offset for this ts\n\n  var o2 = calcOffset(new Date(utcGuess), timezoneString); // If so, offset didn't change and we're done\n\n  if (offset === o2) {\n    return offset;\n  } // If not, change the ts by the difference in the offset\n\n\n  utcGuess -= o2 - offset; // If that gives us the local time we want, we're done\n\n  var o3 = calcOffset(new Date(utcGuess), timezoneString);\n\n  if (o2 === o3) {\n    return o2;\n  } // If it's different, we're in a hole time. The offset has changed, but the we don't adjust the time\n\n\n  return Math.max(o2, o3);\n}\n\nfunction validateTimezone(hours, minutes) {\n  if (minutes != null && (minutes < 0 || minutes > 59)) {\n    return false;\n  }\n\n  return true;\n}","map":{"version":3,"sources":["/home/mimirandi21/code/projects/Full-Stack-Developer-Coding-Challenge-1/rocketfront/node_modules/date-fns-tz/esm/_lib/tzParseTimezone/index.js"],"names":["tzTokenizeDate","MILLISECONDS_IN_HOUR","MILLISECONDS_IN_MINUTE","patterns","timezone","timezoneZ","timezoneHH","timezoneHHMM","timezoneIANA","tzParseTimezone","timezoneString","date","isUtcDate","token","absoluteOffset","exec","hours","parseInt","validateTimezone","NaN","minutes","Date","now","utcDate","toUtcDate","offset","calcOffset","fixedOffset","fixOffset","UTC","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","year","month","day","hour","minute","second","asUTC","asTS","getTime","over","localTS","utcGuess","o2","o3","Math","max"],"mappings":"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","sourcesContent":["import tzTokenizeDate from '../tzTokenizeDate/index.js'\n\nvar MILLISECONDS_IN_HOUR = 3600000\nvar MILLISECONDS_IN_MINUTE = 60000\n\nvar patterns = {\n  timezone: /([Z+-].*)$/,\n  timezoneZ: /^(Z)$/,\n  timezoneHH: /^([+-])(\\d{2})$/,\n  timezoneHHMM: /^([+-])(\\d{2}):?(\\d{2})$/,\n  timezoneIANA: /(UTC|(?:[a-zA-Z]+\\/[a-zA-Z_-]+(?:\\/[a-zA-Z_]+)?))$/,\n}\n\n// Parse various time zone offset formats to an offset in milliseconds\nexport default function tzParseTimezone(timezoneString, date, isUtcDate) {\n  var token\n  var absoluteOffset\n\n  // Z\n  token = patterns.timezoneZ.exec(timezoneString)\n  if (token) {\n    return 0\n  }\n\n  var hours\n\n  // ±hh\n  token = patterns.timezoneHH.exec(timezoneString)\n  if (token) {\n    hours = parseInt(token[2], 10)\n\n    if (!validateTimezone(hours)) {\n      return NaN\n    }\n\n    absoluteOffset = hours * MILLISECONDS_IN_HOUR\n    return token[1] === '+' ? -absoluteOffset : absoluteOffset\n  }\n\n  // ±hh:mm or ±hhmm\n  token = patterns.timezoneHHMM.exec(timezoneString)\n  if (token) {\n    hours = parseInt(token[2], 10)\n    var minutes = parseInt(token[3], 10)\n\n    if (!validateTimezone(hours, minutes)) {\n      return NaN\n    }\n\n    absoluteOffset = hours * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE\n    return token[1] === '+' ? -absoluteOffset : absoluteOffset\n  }\n\n  // IANA time zone\n  token = patterns.timezoneIANA.exec(timezoneString)\n  if (token) {\n    date = new Date(date || Date.now())\n    var utcDate = isUtcDate ? date : toUtcDate(date)\n\n    var offset = calcOffset(utcDate, timezoneString)\n\n    var fixedOffset = isUtcDate ? offset : fixOffset(date, offset, timezoneString)\n\n    return -fixedOffset\n  }\n\n  return 0\n}\n\nfunction toUtcDate(date) {\n  return new Date(\n    Date.UTC(\n      date.getFullYear(),\n      date.getMonth(),\n      date.getDate(),\n      date.getHours(),\n      date.getMinutes(),\n      date.getSeconds(),\n      date.getMilliseconds()\n    )\n  )\n}\n\nfunction calcOffset(date, timezoneString) {\n  var [year, month, day, hour, minute, second] = tzTokenizeDate(date, timezoneString)\n\n  var asUTC = Date.UTC(year, month - 1, day, hour % 24, minute, second)\n\n  var asTS = date.getTime()\n  var over = asTS % 1000\n  asTS -= over >= 0 ? over : 1000 + over\n  return asUTC - asTS\n}\n\nfunction fixOffset(date, offset, timezoneString) {\n  var localTS = date.getTime()\n\n  // Our UTC time is just a guess because our offset is just a guess\n  var utcGuess = localTS - offset\n\n  // Test whether the zone matches the offset for this ts\n  var o2 = calcOffset(new Date(utcGuess), timezoneString)\n\n  // If so, offset didn't change and we're done\n  if (offset === o2) {\n    return offset\n  }\n\n  // If not, change the ts by the difference in the offset\n  utcGuess -= o2 - offset\n\n  // If that gives us the local time we want, we're done\n  var o3 = calcOffset(new Date(utcGuess), timezoneString)\n  if (o2 === o3) {\n    return o2\n  }\n\n  // If it's different, we're in a hole time. The offset has changed, but the we don't adjust the time\n  return Math.max(o2, o3)\n}\n\nfunction validateTimezone(hours, minutes) {\n  if (minutes != null && (minutes < 0 || minutes > 59)) {\n    return false\n  }\n\n  return true\n}\n"]},"metadata":{},"sourceType":"module"}