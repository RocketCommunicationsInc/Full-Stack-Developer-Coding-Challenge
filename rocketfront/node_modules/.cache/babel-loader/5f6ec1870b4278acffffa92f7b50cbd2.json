{"ast":null,"code":"import { isRegExp, isString } from './is';\n/**\n * Truncates given string to the maximum characters count\n *\n * @param str An object that contains serializable values\n * @param max Maximum number of characters in truncated string (0 = unlimited)\n * @returns string Encoded\n */\n\nexport function truncate(str, max) {\n  if (max === void 0) {\n    max = 0;\n  }\n\n  if (typeof str !== 'string' || max === 0) {\n    return str;\n  }\n\n  return str.length <= max ? str : str.substr(0, max) + \"...\";\n}\n/**\n * This is basically just `trim_line` from\n * https://github.com/getsentry/sentry/blob/master/src/sentry/lang/javascript/processor.py#L67\n *\n * @param str An object that contains serializable values\n * @param max Maximum number of characters in truncated string\n * @returns string Encoded\n */\n\nexport function snipLine(line, colno) {\n  var newLine = line;\n  var ll = newLine.length;\n\n  if (ll <= 150) {\n    return newLine;\n  }\n\n  if (colno > ll) {\n    // eslint-disable-next-line no-param-reassign\n    colno = ll;\n  }\n\n  var start = Math.max(colno - 60, 0);\n\n  if (start < 5) {\n    start = 0;\n  }\n\n  var end = Math.min(start + 140, ll);\n\n  if (end > ll - 5) {\n    end = ll;\n  }\n\n  if (end === ll) {\n    start = Math.max(end - 140, 0);\n  }\n\n  newLine = newLine.slice(start, end);\n\n  if (start > 0) {\n    newLine = \"'{snip} \" + newLine;\n  }\n\n  if (end < ll) {\n    newLine += ' {snip}';\n  }\n\n  return newLine;\n}\n/**\n * Join values in array\n * @param input array of values to be joined together\n * @param delimiter string to be placed in-between values\n * @returns Joined values\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nexport function safeJoin(input, delimiter) {\n  if (!Array.isArray(input)) {\n    return '';\n  }\n\n  var output = []; // eslint-disable-next-line @typescript-eslint/prefer-for-of\n\n  for (var i = 0; i < input.length; i++) {\n    var value = input[i];\n\n    try {\n      output.push(String(value));\n    } catch (e) {\n      output.push('[value cannot be serialized]');\n    }\n  }\n\n  return output.join(delimiter);\n}\n/**\n * Checks if the value matches a regex or includes the string\n * @param value The string value to be checked against\n * @param pattern Either a regex or a string that must be contained in value\n */\n\nexport function isMatchingPattern(value, pattern) {\n  if (!isString(value)) {\n    return false;\n  }\n\n  if (isRegExp(pattern)) {\n    return pattern.test(value);\n  }\n\n  if (typeof pattern === 'string') {\n    return value.indexOf(pattern) !== -1;\n  }\n\n  return false;\n}","map":{"version":3,"sources":["../src/string.ts"],"names":[],"mappings":"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","sourcesContent":["import { isRegExp, isString } from './is';\n\n/**\n * Truncates given string to the maximum characters count\n *\n * @param str An object that contains serializable values\n * @param max Maximum number of characters in truncated string (0 = unlimited)\n * @returns string Encoded\n */\nexport function truncate(str: string, max: number = 0): string {\n  if (typeof str !== 'string' || max === 0) {\n    return str;\n  }\n  return str.length <= max ? str : `${str.substr(0, max)}...`;\n}\n\n/**\n * This is basically just `trim_line` from\n * https://github.com/getsentry/sentry/blob/master/src/sentry/lang/javascript/processor.py#L67\n *\n * @param str An object that contains serializable values\n * @param max Maximum number of characters in truncated string\n * @returns string Encoded\n */\nexport function snipLine(line: string, colno: number): string {\n  let newLine = line;\n  const ll = newLine.length;\n  if (ll <= 150) {\n    return newLine;\n  }\n  if (colno > ll) {\n    // eslint-disable-next-line no-param-reassign\n    colno = ll;\n  }\n\n  let start = Math.max(colno - 60, 0);\n  if (start < 5) {\n    start = 0;\n  }\n\n  let end = Math.min(start + 140, ll);\n  if (end > ll - 5) {\n    end = ll;\n  }\n  if (end === ll) {\n    start = Math.max(end - 140, 0);\n  }\n\n  newLine = newLine.slice(start, end);\n  if (start > 0) {\n    newLine = `'{snip} ${newLine}`;\n  }\n  if (end < ll) {\n    newLine += ' {snip}';\n  }\n\n  return newLine;\n}\n\n/**\n * Join values in array\n * @param input array of values to be joined together\n * @param delimiter string to be placed in-between values\n * @returns Joined values\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function safeJoin(input: any[], delimiter?: string): string {\n  if (!Array.isArray(input)) {\n    return '';\n  }\n\n  const output = [];\n  // eslint-disable-next-line @typescript-eslint/prefer-for-of\n  for (let i = 0; i < input.length; i++) {\n    const value = input[i];\n    try {\n      output.push(String(value));\n    } catch (e) {\n      output.push('[value cannot be serialized]');\n    }\n  }\n\n  return output.join(delimiter);\n}\n\n/**\n * Checks if the value matches a regex or includes the string\n * @param value The string value to be checked against\n * @param pattern Either a regex or a string that must be contained in value\n */\nexport function isMatchingPattern(value: string, pattern: RegExp | string): boolean {\n  if (!isString(value)) {\n    return false;\n  }\n\n  if (isRegExp(pattern)) {\n    return (pattern as RegExp).test(value);\n  }\n  if (typeof pattern === 'string') {\n    return value.indexOf(pattern) !== -1;\n  }\n  return false;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}