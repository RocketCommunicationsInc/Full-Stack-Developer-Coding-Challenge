{"ast":null,"code":"import { __values } from \"tslib\";\nimport { API } from '@sentry/core';\nimport { Status } from '@sentry/types';\nimport { logger, parseRetryAfterHeader, PromiseBuffer, SentryError } from '@sentry/utils';\nvar CATEGORY_MAPPING = {\n  event: 'error',\n  transaction: 'transaction',\n  session: 'session'\n};\n/** Base Transport class implementation */\n\nvar BaseTransport =\n/** @class */\nfunction () {\n  function BaseTransport(options) {\n    this.options = options;\n    /** A simple buffer holding all requests. */\n\n    this._buffer = new PromiseBuffer(30);\n    /** Locks transport after receiving rate limits in a response */\n\n    this._rateLimits = {};\n    this._api = new API(options.dsn, options._metadata); // eslint-disable-next-line deprecation/deprecation\n\n    this.url = this._api.getStoreEndpointWithUrlEncodedAuth();\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  BaseTransport.prototype.sendEvent = function (_) {\n    throw new SentryError('Transport Class has to implement `sendEvent` method');\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  BaseTransport.prototype.close = function (timeout) {\n    return this._buffer.drain(timeout);\n  };\n  /**\n   * Handle Sentry repsonse for promise-based transports.\n   */\n\n\n  BaseTransport.prototype._handleResponse = function (_a) {\n    var requestType = _a.requestType,\n        response = _a.response,\n        headers = _a.headers,\n        resolve = _a.resolve,\n        reject = _a.reject;\n    var status = Status.fromHttpCode(response.status);\n    /**\n     * \"The name is case-insensitive.\"\n     * https://developer.mozilla.org/en-US/docs/Web/API/Headers/get\n     */\n\n    var limited = this._handleRateLimit(headers);\n\n    if (limited) logger.warn(\"Too many requests, backing off until: \" + this._disabledUntil(requestType));\n\n    if (status === Status.Success) {\n      resolve({\n        status: status\n      });\n      return;\n    }\n\n    reject(response);\n  };\n  /**\n   * Gets the time that given category is disabled until for rate limiting\n   */\n\n\n  BaseTransport.prototype._disabledUntil = function (requestType) {\n    var category = CATEGORY_MAPPING[requestType];\n    return this._rateLimits[category] || this._rateLimits.all;\n  };\n  /**\n   * Checks if a category is rate limited\n   */\n\n\n  BaseTransport.prototype._isRateLimited = function (requestType) {\n    return this._disabledUntil(requestType) > new Date(Date.now());\n  };\n  /**\n   * Sets internal _rateLimits from incoming headers. Returns true if headers contains a non-empty rate limiting header.\n   */\n\n\n  BaseTransport.prototype._handleRateLimit = function (headers) {\n    var e_1, _a, e_2, _b;\n\n    var now = Date.now();\n    var rlHeader = headers['x-sentry-rate-limits'];\n    var raHeader = headers['retry-after'];\n\n    if (rlHeader) {\n      try {\n        // rate limit headers are of the form\n        //     <header>,<header>,..\n        // where each <header> is of the form\n        //     <retry_after>: <categories>: <scope>: <reason_code>\n        // where\n        //     <retry_after> is a delay in ms\n        //     <categories> is the event type(s) (error, transaction, etc) being rate limited and is of the form\n        //         <category>;<category>;...\n        //     <scope> is what's being limited (org, project, or key) - ignored by SDK\n        //     <reason_code> is an arbitrary string like \"org_quota\" - ignored by SDK\n        for (var _c = __values(rlHeader.trim().split(',')), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var limit = _d.value;\n          var parameters = limit.split(':', 2);\n          var headerDelay = parseInt(parameters[0], 10);\n          var delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1000; // 60sec default\n\n          try {\n            for (var _e = (e_2 = void 0, __values(parameters[1].split(';'))), _f = _e.next(); !_f.done; _f = _e.next()) {\n              var category = _f.value;\n              this._rateLimits[category || 'all'] = new Date(now + delay);\n            }\n          } catch (e_2_1) {\n            e_2 = {\n              error: e_2_1\n            };\n          } finally {\n            try {\n              if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n            } finally {\n              if (e_2) throw e_2.error;\n            }\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      return true;\n    } else if (raHeader) {\n      this._rateLimits.all = new Date(now + parseRetryAfterHeader(now, raHeader));\n      return true;\n    }\n\n    return false;\n  };\n\n  return BaseTransport;\n}();\n\nexport { BaseTransport };","map":{"version":3,"sources":["../../src/transports/base.ts"],"names":[],"mappings":"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","sourcesContent":["import { API } from '@sentry/core';\nimport {\n  Event,\n  Response as SentryResponse,\n  SentryRequestType,\n  Status,\n  Transport,\n  TransportOptions,\n} from '@sentry/types';\nimport { logger, parseRetryAfterHeader, PromiseBuffer, SentryError } from '@sentry/utils';\n\nconst CATEGORY_MAPPING: {\n  [key in SentryRequestType]: string;\n} = {\n  event: 'error',\n  transaction: 'transaction',\n  session: 'session',\n};\n\n/** Base Transport class implementation */\nexport abstract class BaseTransport implements Transport {\n  /**\n   * @deprecated\n   */\n  public url: string;\n\n  /** Helper to get Sentry API endpoints. */\n  protected readonly _api: API;\n\n  /** A simple buffer holding all requests. */\n  protected readonly _buffer: PromiseBuffer<SentryResponse> = new PromiseBuffer(30);\n\n  /** Locks transport after receiving rate limits in a response */\n  protected readonly _rateLimits: Record<string, Date> = {};\n\n  public constructor(public options: TransportOptions) {\n    this._api = new API(options.dsn, options._metadata);\n    // eslint-disable-next-line deprecation/deprecation\n    this.url = this._api.getStoreEndpointWithUrlEncodedAuth();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public sendEvent(_: Event): PromiseLike<SentryResponse> {\n    throw new SentryError('Transport Class has to implement `sendEvent` method');\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public close(timeout?: number): PromiseLike<boolean> {\n    return this._buffer.drain(timeout);\n  }\n\n  /**\n   * Handle Sentry repsonse for promise-based transports.\n   */\n  protected _handleResponse({\n    requestType,\n    response,\n    headers,\n    resolve,\n    reject,\n  }: {\n    requestType: SentryRequestType;\n    response: Response | XMLHttpRequest;\n    headers: Record<string, string | null>;\n    resolve: (value?: SentryResponse | PromiseLike<SentryResponse> | null | undefined) => void;\n    reject: (reason?: unknown) => void;\n  }): void {\n    const status = Status.fromHttpCode(response.status);\n    /**\n     * \"The name is case-insensitive.\"\n     * https://developer.mozilla.org/en-US/docs/Web/API/Headers/get\n     */\n    const limited = this._handleRateLimit(headers);\n    if (limited) logger.warn(`Too many requests, backing off until: ${this._disabledUntil(requestType)}`);\n\n    if (status === Status.Success) {\n      resolve({ status });\n      return;\n    }\n\n    reject(response);\n  }\n\n  /**\n   * Gets the time that given category is disabled until for rate limiting\n   */\n  protected _disabledUntil(requestType: SentryRequestType): Date {\n    const category = CATEGORY_MAPPING[requestType];\n    return this._rateLimits[category] || this._rateLimits.all;\n  }\n\n  /**\n   * Checks if a category is rate limited\n   */\n  protected _isRateLimited(requestType: SentryRequestType): boolean {\n    return this._disabledUntil(requestType) > new Date(Date.now());\n  }\n\n  /**\n   * Sets internal _rateLimits from incoming headers. Returns true if headers contains a non-empty rate limiting header.\n   */\n  protected _handleRateLimit(headers: Record<string, string | null>): boolean {\n    const now = Date.now();\n    const rlHeader = headers['x-sentry-rate-limits'];\n    const raHeader = headers['retry-after'];\n\n    if (rlHeader) {\n      // rate limit headers are of the form\n      //     <header>,<header>,..\n      // where each <header> is of the form\n      //     <retry_after>: <categories>: <scope>: <reason_code>\n      // where\n      //     <retry_after> is a delay in ms\n      //     <categories> is the event type(s) (error, transaction, etc) being rate limited and is of the form\n      //         <category>;<category>;...\n      //     <scope> is what's being limited (org, project, or key) - ignored by SDK\n      //     <reason_code> is an arbitrary string like \"org_quota\" - ignored by SDK\n      for (const limit of rlHeader.trim().split(',')) {\n        const parameters = limit.split(':', 2);\n        const headerDelay = parseInt(parameters[0], 10);\n        const delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1000; // 60sec default\n        for (const category of parameters[1].split(';')) {\n          this._rateLimits[category || 'all'] = new Date(now + delay);\n        }\n      }\n      return true;\n    } else if (raHeader) {\n      this._rateLimits.all = new Date(now + parseRetryAfterHeader(now, raHeader));\n      return true;\n    }\n    return false;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}