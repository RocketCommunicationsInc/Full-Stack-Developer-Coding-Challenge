{"ast":null,"code":"import { __assign, __read, __rest, __spread } from \"tslib\";\n/** Extract sdk info from from the API metadata */\n\nfunction getSdkMetadataForEnvelopeHeader(api) {\n  if (!api.metadata || !api.metadata.sdk) {\n    return;\n  }\n\n  var _a = api.metadata.sdk,\n      name = _a.name,\n      version = _a.version;\n  return {\n    name: name,\n    version: version\n  };\n}\n/**\n * Apply SdkInfo (name, version, packages, integrations) to the corresponding event key.\n * Merge with existing data if any.\n **/\n\n\nfunction enhanceEventWithSdkInfo(event, sdkInfo) {\n  if (!sdkInfo) {\n    return event;\n  }\n\n  event.sdk = event.sdk || {\n    name: sdkInfo.name,\n    version: sdkInfo.version\n  };\n  event.sdk.name = event.sdk.name || sdkInfo.name;\n  event.sdk.version = event.sdk.version || sdkInfo.version;\n  event.sdk.integrations = __spread(event.sdk.integrations || [], sdkInfo.integrations || []);\n  event.sdk.packages = __spread(event.sdk.packages || [], sdkInfo.packages || []);\n  return event;\n}\n/** Creates a SentryRequest from an event. */\n\n\nexport function sessionToSentryRequest(session, api) {\n  var sdkInfo = getSdkMetadataForEnvelopeHeader(api);\n  var envelopeHeaders = JSON.stringify(__assign({\n    sent_at: new Date().toISOString()\n  }, sdkInfo && {\n    sdk: sdkInfo\n  }));\n  var itemHeaders = JSON.stringify({\n    type: 'session'\n  });\n  return {\n    body: envelopeHeaders + \"\\n\" + itemHeaders + \"\\n\" + JSON.stringify(session),\n    type: 'session',\n    url: api.getEnvelopeEndpointWithUrlEncodedAuth()\n  };\n}\n/** Creates a SentryRequest from an event. */\n\nexport function eventToSentryRequest(event, api) {\n  var sdkInfo = getSdkMetadataForEnvelopeHeader(api);\n  var eventType = event.type || 'event';\n  var useEnvelope = eventType === 'transaction';\n\n  var _a = event.debug_meta || {},\n      transactionSampling = _a.transactionSampling,\n      metadata = __rest(_a, [\"transactionSampling\"]);\n\n  var _b = transactionSampling || {},\n      samplingMethod = _b.method,\n      sampleRate = _b.rate;\n\n  if (Object.keys(metadata).length === 0) {\n    delete event.debug_meta;\n  } else {\n    event.debug_meta = metadata;\n  }\n\n  var req = {\n    body: JSON.stringify(sdkInfo ? enhanceEventWithSdkInfo(event, api.metadata.sdk) : event),\n    type: eventType,\n    url: useEnvelope ? api.getEnvelopeEndpointWithUrlEncodedAuth() : api.getStoreEndpointWithUrlEncodedAuth()\n  }; // https://develop.sentry.dev/sdk/envelopes/\n  // Since we don't need to manipulate envelopes nor store them, there is no\n  // exported concept of an Envelope with operations including serialization and\n  // deserialization. Instead, we only implement a minimal subset of the spec to\n  // serialize events inline here.\n\n  if (useEnvelope) {\n    var envelopeHeaders = JSON.stringify(__assign({\n      event_id: event.event_id,\n      sent_at: new Date().toISOString()\n    }, sdkInfo && {\n      sdk: sdkInfo\n    }));\n    var itemHeaders = JSON.stringify({\n      type: event.type,\n      // TODO: Right now, sampleRate may or may not be defined (it won't be in the cases of inheritance and\n      // explicitly-set sampling decisions). Are we good with that?\n      sample_rates: [{\n        id: samplingMethod,\n        rate: sampleRate\n      }]\n    }); // The trailing newline is optional. We intentionally don't send it to avoid\n    // sending unnecessary bytes.\n    //\n    // const envelope = `${envelopeHeaders}\\n${itemHeaders}\\n${req.body}\\n`;\n\n    var envelope = envelopeHeaders + \"\\n\" + itemHeaders + \"\\n\" + req.body;\n    req.body = envelope;\n  }\n\n  return req;\n}","map":{"version":3,"sources":["../src/request.ts"],"names":[],"mappings":"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","sourcesContent":["import { Event, SdkInfo, SentryRequest, Session } from '@sentry/types';\n\nimport { API } from './api';\n\n/** Extract sdk info from from the API metadata */\nfunction getSdkMetadataForEnvelopeHeader(api: API): SdkInfo | undefined {\n  if (!api.metadata || !api.metadata.sdk) {\n    return;\n  }\n  const { name, version } = api.metadata.sdk;\n  return { name, version };\n}\n\n/**\n * Apply SdkInfo (name, version, packages, integrations) to the corresponding event key.\n * Merge with existing data if any.\n **/\nfunction enhanceEventWithSdkInfo(event: Event, sdkInfo?: SdkInfo): Event {\n  if (!sdkInfo) {\n    return event;\n  }\n\n  event.sdk = event.sdk || {\n    name: sdkInfo.name,\n    version: sdkInfo.version,\n  };\n  event.sdk.name = event.sdk.name || sdkInfo.name;\n  event.sdk.version = event.sdk.version || sdkInfo.version;\n  event.sdk.integrations = [...(event.sdk.integrations || []), ...(sdkInfo.integrations || [])];\n  event.sdk.packages = [...(event.sdk.packages || []), ...(sdkInfo.packages || [])];\n  return event;\n}\n\n/** Creates a SentryRequest from an event. */\nexport function sessionToSentryRequest(session: Session, api: API): SentryRequest {\n  const sdkInfo = getSdkMetadataForEnvelopeHeader(api);\n  const envelopeHeaders = JSON.stringify({\n    sent_at: new Date().toISOString(),\n    ...(sdkInfo && { sdk: sdkInfo }),\n  });\n  const itemHeaders = JSON.stringify({\n    type: 'session',\n  });\n\n  return {\n    body: `${envelopeHeaders}\\n${itemHeaders}\\n${JSON.stringify(session)}`,\n    type: 'session',\n    url: api.getEnvelopeEndpointWithUrlEncodedAuth(),\n  };\n}\n\n/** Creates a SentryRequest from an event. */\nexport function eventToSentryRequest(event: Event, api: API): SentryRequest {\n  const sdkInfo = getSdkMetadataForEnvelopeHeader(api);\n  const eventType = event.type || 'event';\n  const useEnvelope = eventType === 'transaction';\n\n  const { transactionSampling, ...metadata } = event.debug_meta || {};\n  const { method: samplingMethod, rate: sampleRate } = transactionSampling || {};\n  if (Object.keys(metadata).length === 0) {\n    delete event.debug_meta;\n  } else {\n    event.debug_meta = metadata;\n  }\n\n  const req: SentryRequest = {\n    body: JSON.stringify(sdkInfo ? enhanceEventWithSdkInfo(event, api.metadata.sdk) : event),\n    type: eventType,\n    url: useEnvelope ? api.getEnvelopeEndpointWithUrlEncodedAuth() : api.getStoreEndpointWithUrlEncodedAuth(),\n  };\n\n  // https://develop.sentry.dev/sdk/envelopes/\n\n  // Since we don't need to manipulate envelopes nor store them, there is no\n  // exported concept of an Envelope with operations including serialization and\n  // deserialization. Instead, we only implement a minimal subset of the spec to\n  // serialize events inline here.\n  if (useEnvelope) {\n    const envelopeHeaders = JSON.stringify({\n      event_id: event.event_id,\n      sent_at: new Date().toISOString(),\n      ...(sdkInfo && { sdk: sdkInfo }),\n    });\n    const itemHeaders = JSON.stringify({\n      type: event.type,\n\n      // TODO: Right now, sampleRate may or may not be defined (it won't be in the cases of inheritance and\n      // explicitly-set sampling decisions). Are we good with that?\n      sample_rates: [{ id: samplingMethod, rate: sampleRate }],\n\n      // The content-type is assumed to be 'application/json' and not part of\n      // the current spec for transaction items, so we don't bloat the request\n      // body with it.\n      //\n      // content_type: 'application/json',\n      //\n      // The length is optional. It must be the number of bytes in req.Body\n      // encoded as UTF-8. Since the server can figure this out and would\n      // otherwise refuse events that report the length incorrectly, we decided\n      // not to send the length to avoid problems related to reporting the wrong\n      // size and to reduce request body size.\n      //\n      // length: new TextEncoder().encode(req.body).length,\n    });\n    // The trailing newline is optional. We intentionally don't send it to avoid\n    // sending unnecessary bytes.\n    //\n    // const envelope = `${envelopeHeaders}\\n${itemHeaders}\\n${req.body}\\n`;\n    const envelope = `${envelopeHeaders}\\n${itemHeaders}\\n${req.body}`;\n    req.body = envelope;\n  }\n\n  return req;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}